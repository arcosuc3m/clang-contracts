; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=+avx2 | FileCheck --check-prefix=X86 %s
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=+avx2 | FileCheck --check-prefix=X64 %s

declare <2 x i32> @llvm.masked.gather.v2i32(<2 x i32*> %ptrs, i32 %align, <2 x i1> %masks, <2 x i32> %passthro)

define <2 x i32> @masked_gather_v2i32(<2 x i32*>* %ptr, <2 x i1> %masks, <2 x i32> %passthro) {
; X86-LABEL: masked_gather_v2i32:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vpmovzxdq {{.*#+}} xmm3 = mem[0],zero,mem[1],zero
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM2
; X86-NEXT:    je .LBB0_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovd {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB0_2: # %else
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB0_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vpinsrd $2, (%eax), %xmm2, %xmm2
; X86-NEXT:  .LBB0_4: # %else2
; X86-NEXT:    vpsllq $63, %xmm0, %xmm0
; X86-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v2i32:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %xmm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM2
; X64-NEXT:    je .LBB0_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovd {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB0_2: # %else
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB0_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    movl (%rax), %eax
; X64-NEXT:    vpinsrq $1, %rax, %xmm2, %xmm2
; X64-NEXT:  .LBB0_4: # %else2
; X64-NEXT:    vpsllq $63, %xmm0, %xmm0
; X64-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X64-NEXT:    retq
entry:
  %ld  = load <2 x i32*>, <2 x i32*>* %ptr
  %res = call <2 x i32> @llvm.masked.gather.v2i32(<2 x i32*> %ld, i32 0, <2 x i1> %masks, <2 x i32> %passthro)
  ret <2 x i32> %res
}

declare <2 x float> @llvm.masked.gather.v2float(<2 x float*> %ptrs, i32 %align, <2 x i1> %masks, <2 x float> %passthro)

define <2 x float> @masked_gather_v2float(<2 x float*>* %ptr, <2 x i1> %masks, <2 x float> %passthro) {
; X86-LABEL: masked_gather_v2float:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vpmovzxdq {{.*#+}} xmm3 = mem[0],zero,mem[1],zero
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM2
; X86-NEXT:    je .LBB1_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB1_2: # %else
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB1_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm2 = xmm2[0],mem[0],xmm2[2,3]
; X86-NEXT:  .LBB1_4: # %else2
; X86-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,2,2,3]
; X86-NEXT:    vpslld $31, %xmm0, %xmm0
; X86-NEXT:    vblendvps %xmm0, %xmm2, %xmm1, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v2float:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %xmm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM2
; X64-NEXT:    je .LBB1_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB1_2: # %else
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB1_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm2 = xmm2[0],mem[0],xmm2[2,3]
; X64-NEXT:  .LBB1_4: # %else2
; X64-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,2,2,3]
; X64-NEXT:    vpslld $31, %xmm0, %xmm0
; X64-NEXT:    vblendvps %xmm0, %xmm2, %xmm1, %xmm0
; X64-NEXT:    retq
entry:
  %ld  = load <2 x float*>, <2 x float*>* %ptr
  %res = call <2 x float> @llvm.masked.gather.v2float(<2 x float*> %ld, i32 0, <2 x i1> %masks, <2 x float> %passthro)
  ret <2 x float> %res
}

declare <4 x i32> @llvm.masked.gather.v4i32(<4 x i32*> %ptrs, i32 %align, <4 x i1> %masks, <4 x i32> %passthro)

define <4 x i32> @masked_gather_v4i32(<4 x i32*> %ptrs, <4 x i1> %masks, <4 x i32> %passthro) {
; X86-LABEL: masked_gather_v4i32:
; X86:       # BB#0: # %entry
; X86-NEXT:    vpextrb $0, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM3
; X86-NEXT:    je .LBB2_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm0, %eax
; X86-NEXT:    vmovd {{.*#+}} xmm3 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB2_2: # %else
; X86-NEXT:    vpextrb $4, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB2_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm0, %eax
; X86-NEXT:    vpinsrd $1, (%eax), %xmm3, %xmm3
; X86-NEXT:  .LBB2_4: # %else2
; X86-NEXT:    vpextrb $8, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB2_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm0, %eax
; X86-NEXT:    vpinsrd $2, (%eax), %xmm3, %xmm3
; X86-NEXT:  .LBB2_6: # %else5
; X86-NEXT:    vpextrb $12, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB2_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm0, %eax
; X86-NEXT:    vpinsrd $3, (%eax), %xmm3, %xmm3
; X86-NEXT:  .LBB2_8: # %else8
; X86-NEXT:    vpslld $31, %xmm1, %xmm0
; X86-NEXT:    vblendvps %xmm0, %xmm3, %xmm2, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v4i32:
; X64:       # BB#0: # %entry
; X64-NEXT:    vpextrb $0, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM3
; X64-NEXT:    je .LBB2_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm0, %rax
; X64-NEXT:    vmovd {{.*#+}} xmm3 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB2_2: # %else
; X64-NEXT:    vpextrb $4, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB2_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm0, %rax
; X64-NEXT:    vpinsrd $1, (%rax), %xmm3, %xmm3
; X64-NEXT:  .LBB2_4: # %else2
; X64-NEXT:    vpextrb $8, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB2_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm0, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vpinsrd $2, (%rax), %xmm3, %xmm3
; X64-NEXT:  .LBB2_6: # %else5
; X64-NEXT:    vpextrb $12, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB2_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm0, %xmm0
; X64-NEXT:    vpextrq $1, %xmm0, %rax
; X64-NEXT:    vpinsrd $3, (%rax), %xmm3, %xmm3
; X64-NEXT:  .LBB2_8: # %else8
; X64-NEXT:    vpslld $31, %xmm1, %xmm0
; X64-NEXT:    vblendvps %xmm0, %xmm3, %xmm2, %xmm0
; X64-NEXT:    vzeroupper
; X64-NEXT:    retq
entry:
  %res = call <4 x i32> @llvm.masked.gather.v4i32(<4 x i32*> %ptrs, i32 0, <4 x i1> %masks, <4 x i32> %passthro)
  ret <4 x i32> %res
}

declare <4 x float> @llvm.masked.gather.v4float(<4 x float*> %ptrs, i32 %align, <4 x i1> %masks, <4 x float> %passthro)

define <4 x float> @masked_gather_v4float(<4 x float*> %ptrs, <4 x i1> %masks, <4 x float> %passthro) {
; X86-LABEL: masked_gather_v4float:
; X86:       # BB#0: # %entry
; X86-NEXT:    vpextrb $0, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM3
; X86-NEXT:    je .LBB3_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm0, %eax
; X86-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB3_2: # %else
; X86-NEXT:    vpextrb $4, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB3_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm0, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0],mem[0],xmm3[2,3]
; X86-NEXT:  .LBB3_4: # %else2
; X86-NEXT:    vpextrb $8, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB3_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm0, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1],mem[0],xmm3[3]
; X86-NEXT:  .LBB3_6: # %else5
; X86-NEXT:    vpextrb $12, %xmm1, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB3_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm0, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1,2],mem[0]
; X86-NEXT:  .LBB3_8: # %else8
; X86-NEXT:    vpslld $31, %xmm1, %xmm0
; X86-NEXT:    vblendvps %xmm0, %xmm3, %xmm2, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v4float:
; X64:       # BB#0: # %entry
; X64-NEXT:    vpextrb $0, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM3
; X64-NEXT:    je .LBB3_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm0, %rax
; X64-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB3_2: # %else
; X64-NEXT:    vpextrb $4, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB3_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm0, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0],mem[0],xmm3[2,3]
; X64-NEXT:  .LBB3_4: # %else2
; X64-NEXT:    vpextrb $8, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB3_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm0, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1],mem[0],xmm3[3]
; X64-NEXT:  .LBB3_6: # %else5
; X64-NEXT:    vpextrb $12, %xmm1, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB3_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm0, %xmm0
; X64-NEXT:    vpextrq $1, %xmm0, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1,2],mem[0]
; X64-NEXT:  .LBB3_8: # %else8
; X64-NEXT:    vpslld $31, %xmm1, %xmm0
; X64-NEXT:    vblendvps %xmm0, %xmm3, %xmm2, %xmm0
; X64-NEXT:    vzeroupper
; X64-NEXT:    retq
entry:
  %res = call <4 x float> @llvm.masked.gather.v4float(<4 x float*> %ptrs, i32 0, <4 x i1> %masks, <4 x float> %passthro)
  ret <4 x float> %res
}

declare <8 x i32> @llvm.masked.gather.v8i32(<8 x i32*> %ptrs, i32 %align, <8 x i1> %masks, <8 x i32> %passthro)

define <8 x i32> @masked_gather_v8i32(<8 x i32*>* %ptr, <8 x i1> %masks, <8 x i32> %passthro) {
; X86-LABEL: masked_gather_v8i32:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vmovdqa (%eax), %ymm3
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %YMM2
; X86-NEXT:    je .LBB4_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovd {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB4_2: # %else
; X86-NEXT:    vpextrb $2, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm3, %eax
; X86-NEXT:    vpinsrd $1, (%eax), %xmm2, %xmm4
; X86-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB4_4: # %else2
; X86-NEXT:    vpextrb $4, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vpinsrd $2, (%eax), %xmm2, %xmm4
; X86-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB4_6: # %else5
; X86-NEXT:    vpextrb $6, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vpinsrd $3, (%eax), %xmm2, %xmm4
; X86-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB4_8: # %else8
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_10
; X86-NEXT:  # BB#9: # %cond.load10
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vmovd %xmm4, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X86-NEXT:    vpinsrd $0, (%eax), %xmm4, %xmm4
; X86-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB4_10: # %else11
; X86-NEXT:    vpextrb $10, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_12
; X86-NEXT:  # BB#11: # %cond.load13
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vpextrd $1, %xmm4, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X86-NEXT:    vpinsrd $1, (%eax), %xmm4, %xmm4
; X86-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB4_12: # %else14
; X86-NEXT:    vpextrb $12, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_14
; X86-NEXT:  # BB#13: # %cond.load16
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vpextrd $2, %xmm4, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X86-NEXT:    vpinsrd $2, (%eax), %xmm4, %xmm4
; X86-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB4_14: # %else17
; X86-NEXT:    vpextrb $14, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB4_16
; X86-NEXT:  # BB#15: # %cond.load19
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm3
; X86-NEXT:    vpinsrd $3, (%eax), %xmm3, %xmm3
; X86-NEXT:    vinserti128 $1, %xmm3, %ymm2, %ymm2
; X86-NEXT:  .LBB4_16: # %else20
; X86-NEXT:    vpmovzxwd {{.*#+}} ymm0 = xmm0[0],zero,xmm0[1],zero,xmm0[2],zero,xmm0[3],zero,xmm0[4],zero,xmm0[5],zero,xmm0[6],zero,xmm0[7],zero
; X86-NEXT:    vpslld $31, %ymm0, %ymm0
; X86-NEXT:    vblendvps %ymm0, %ymm2, %ymm1, %ymm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v8i32:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %ymm4
; X64-NEXT:    vmovdqa 32(%rdi), %ymm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %YMM2
; X64-NEXT:    je .LBB4_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vmovd {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB4_2: # %else
; X64-NEXT:    vpextrb $2, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm4, %rax
; X64-NEXT:    vpinsrd $1, (%rax), %xmm2, %xmm5
; X64-NEXT:    vpblendd {{.*#+}} ymm2 = ymm5[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB4_4: # %else2
; X64-NEXT:    vpextrb $4, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm4, %xmm5
; X64-NEXT:    vmovq %xmm5, %rax
; X64-NEXT:    vpinsrd $2, (%rax), %xmm2, %xmm5
; X64-NEXT:    vpblendd {{.*#+}} ymm2 = ymm5[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB4_6: # %else5
; X64-NEXT:    vpextrb $6, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm4, %xmm4
; X64-NEXT:    vpextrq $1, %xmm4, %rax
; X64-NEXT:    vpinsrd $3, (%rax), %xmm2, %xmm4
; X64-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB4_8: # %else8
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_10
; X64-NEXT:  # BB#9: # %cond.load10
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X64-NEXT:    vpinsrd $0, (%rax), %xmm4, %xmm4
; X64-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB4_10: # %else11
; X64-NEXT:    vpextrb $10, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_12
; X64-NEXT:  # BB#11: # %cond.load13
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X64-NEXT:    vpinsrd $1, (%rax), %xmm4, %xmm4
; X64-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB4_12: # %else14
; X64-NEXT:    vpextrb $12, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_14
; X64-NEXT:  # BB#13: # %cond.load16
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X64-NEXT:    vpinsrd $2, (%rax), %xmm4, %xmm4
; X64-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB4_14: # %else17
; X64-NEXT:    vpextrb $14, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB4_16
; X64-NEXT:  # BB#15: # %cond.load19
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm3
; X64-NEXT:    vpinsrd $3, (%rax), %xmm3, %xmm3
; X64-NEXT:    vinserti128 $1, %xmm3, %ymm2, %ymm2
; X64-NEXT:  .LBB4_16: # %else20
; X64-NEXT:    vpmovzxwd {{.*#+}} ymm0 = xmm0[0],zero,xmm0[1],zero,xmm0[2],zero,xmm0[3],zero,xmm0[4],zero,xmm0[5],zero,xmm0[6],zero,xmm0[7],zero
; X64-NEXT:    vpslld $31, %ymm0, %ymm0
; X64-NEXT:    vblendvps %ymm0, %ymm2, %ymm1, %ymm0
; X64-NEXT:    retq
entry:
  %ld  = load <8 x i32*>, <8 x i32*>* %ptr
  %res = call <8 x i32> @llvm.masked.gather.v8i32(<8 x i32*> %ld, i32 0, <8 x i1> %masks, <8 x i32> %passthro)
  ret <8 x i32> %res
}

declare <8 x float> @llvm.masked.gather.v8float(<8 x float*> %ptrs, i32 %align, <8 x i1> %masks, <8 x float> %passthro)

define <8 x float> @masked_gather_v8float(<8 x float*>* %ptr, <8 x i1> %masks, <8 x float> %passthro) {
; X86-LABEL: masked_gather_v8float:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vmovdqa (%eax), %ymm3
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %YMM2
; X86-NEXT:    je .LBB5_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X86-NEXT:  .LBB5_2: # %else
; X86-NEXT:    vpextrb $2, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm3, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm4 = xmm2[0],mem[0],xmm2[2,3]
; X86-NEXT:    vblendps {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB5_4: # %else2
; X86-NEXT:    vpextrb $4, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm4 = xmm2[0,1],mem[0],xmm2[3]
; X86-NEXT:    vblendps {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB5_6: # %else5
; X86-NEXT:    vpextrb $6, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vinsertps {{.*#+}} xmm4 = xmm2[0,1,2],mem[0]
; X86-NEXT:    vblendps {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB5_8: # %else8
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_10
; X86-NEXT:  # BB#9: # %cond.load10
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vmovd %xmm4, %eax
; X86-NEXT:    vmovss {{.*#+}} xmm4 = mem[0],zero,zero,zero
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm5
; X86-NEXT:    vblendps {{.*#+}} xmm4 = xmm4[0],xmm5[1,2,3]
; X86-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB5_10: # %else11
; X86-NEXT:    vpextrb $10, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_12
; X86-NEXT:  # BB#11: # %cond.load13
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vpextrd $1, %xmm4, %eax
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X86-NEXT:    vinsertps {{.*#+}} xmm4 = xmm4[0],mem[0],xmm4[2,3]
; X86-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB5_12: # %else14
; X86-NEXT:    vpextrb $12, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_14
; X86-NEXT:  # BB#13: # %cond.load16
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X86-NEXT:    vpextrd $2, %xmm4, %eax
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X86-NEXT:    vinsertps {{.*#+}} xmm4 = xmm4[0,1],mem[0],xmm4[3]
; X86-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB5_14: # %else17
; X86-NEXT:    vpextrb $14, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB5_16
; X86-NEXT:  # BB#15: # %cond.load19
; X86-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm3
; X86-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1,2],mem[0]
; X86-NEXT:    vinsertf128 $1, %xmm3, %ymm2, %ymm2
; X86-NEXT:  .LBB5_16: # %else20
; X86-NEXT:    vpmovzxwd {{.*#+}} ymm0 = xmm0[0],zero,xmm0[1],zero,xmm0[2],zero,xmm0[3],zero,xmm0[4],zero,xmm0[5],zero,xmm0[6],zero,xmm0[7],zero
; X86-NEXT:    vpslld $31, %ymm0, %ymm0
; X86-NEXT:    vblendvps %ymm0, %ymm2, %ymm1, %ymm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v8float:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %ymm4
; X64-NEXT:    vmovdqa 32(%rdi), %ymm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %YMM2
; X64-NEXT:    je .LBB5_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; X64-NEXT:  .LBB5_2: # %else
; X64-NEXT:    vpextrb $2, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm4, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm5 = xmm2[0],mem[0],xmm2[2,3]
; X64-NEXT:    vblendps {{.*#+}} ymm2 = ymm5[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB5_4: # %else2
; X64-NEXT:    vpextrb $4, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm4, %xmm5
; X64-NEXT:    vmovq %xmm5, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm5 = xmm2[0,1],mem[0],xmm2[3]
; X64-NEXT:    vblendps {{.*#+}} ymm2 = ymm5[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB5_6: # %else5
; X64-NEXT:    vpextrb $6, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm4, %xmm4
; X64-NEXT:    vpextrq $1, %xmm4, %rax
; X64-NEXT:    vinsertps {{.*#+}} xmm4 = xmm2[0,1,2],mem[0]
; X64-NEXT:    vblendps {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB5_8: # %else8
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_10
; X64-NEXT:  # BB#9: # %cond.load10
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovss {{.*#+}} xmm4 = mem[0],zero,zero,zero
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm5
; X64-NEXT:    vblendps {{.*#+}} xmm4 = xmm4[0],xmm5[1,2,3]
; X64-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB5_10: # %else11
; X64-NEXT:    vpextrb $10, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_12
; X64-NEXT:  # BB#11: # %cond.load13
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X64-NEXT:    vinsertps {{.*#+}} xmm4 = xmm4[0],mem[0],xmm4[2,3]
; X64-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB5_12: # %else14
; X64-NEXT:    vpextrb $12, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_14
; X64-NEXT:  # BB#13: # %cond.load16
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X64-NEXT:    vinsertps {{.*#+}} xmm4 = xmm4[0,1],mem[0],xmm4[3]
; X64-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB5_14: # %else17
; X64-NEXT:    vpextrb $14, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB5_16
; X64-NEXT:  # BB#15: # %cond.load19
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm3
; X64-NEXT:    vinsertps {{.*#+}} xmm3 = xmm3[0,1,2],mem[0]
; X64-NEXT:    vinsertf128 $1, %xmm3, %ymm2, %ymm2
; X64-NEXT:  .LBB5_16: # %else20
; X64-NEXT:    vpmovzxwd {{.*#+}} ymm0 = xmm0[0],zero,xmm0[1],zero,xmm0[2],zero,xmm0[3],zero,xmm0[4],zero,xmm0[5],zero,xmm0[6],zero,xmm0[7],zero
; X64-NEXT:    vpslld $31, %ymm0, %ymm0
; X64-NEXT:    vblendvps %ymm0, %ymm2, %ymm1, %ymm0
; X64-NEXT:    retq
entry:
  %ld  = load <8 x float*>, <8 x float*>* %ptr
  %res = call <8 x float> @llvm.masked.gather.v8float(<8 x float*> %ld, i32 0, <8 x i1> %masks, <8 x float> %passthro)
  ret <8 x float> %res
}

declare <4 x i64> @llvm.masked.gather.v4i64(<4 x i64*> %ptrs, i32 %align, <4 x i1> %masks, <4 x i64> %passthro)

define <4 x i64> @masked_gather_v4i64(<4 x i64*>* %ptr, <4 x i1> %masks, <4 x i64> %passthro) {
; X86-LABEL: masked_gather_v4i64:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vmovdqa (%eax), %xmm3
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %YMM2
; X86-NEXT:    je .LBB6_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovq {{.*#+}} xmm2 = mem[0],zero
; X86-NEXT:  .LBB6_2: # %else
; X86-NEXT:    vpextrb $4, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB6_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm3, %eax
; X86-NEXT:    vpinsrd $2, (%eax), %xmm2, %xmm4
; X86-NEXT:    vpinsrd $3, 4(%eax), %xmm4, %xmm4
; X86-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X86-NEXT:  .LBB6_4: # %else2
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB6_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X86-NEXT:    vpinsrd $0, (%eax), %xmm4, %xmm4
; X86-NEXT:    vpinsrd $1, 4(%eax), %xmm4, %xmm4
; X86-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB6_6: # %else5
; X86-NEXT:    vpextrb $12, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB6_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vextracti128 $1, %ymm2, %xmm3
; X86-NEXT:    vpinsrd $2, (%eax), %xmm3, %xmm3
; X86-NEXT:    vpinsrd $3, 4(%eax), %xmm3, %xmm3
; X86-NEXT:    vinserti128 $1, %xmm3, %ymm2, %ymm2
; X86-NEXT:  .LBB6_8: # %else8
; X86-NEXT:    vpslld $31, %xmm0, %xmm0
; X86-NEXT:    vpmovsxdq %xmm0, %ymm0
; X86-NEXT:    vblendvpd %ymm0, %ymm2, %ymm1, %ymm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v4i64:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %ymm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %YMM2
; X64-NEXT:    je .LBB6_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovq {{.*#+}} xmm2 = mem[0],zero
; X64-NEXT:  .LBB6_2: # %else
; X64-NEXT:    vpextrb $4, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB6_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vpinsrq $1, (%rax), %xmm2, %xmm4
; X64-NEXT:    vpblendd {{.*#+}} ymm2 = ymm4[0,1,2,3],ymm2[4,5,6,7]
; X64-NEXT:  .LBB6_4: # %else2
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB6_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm4
; X64-NEXT:    vpinsrq $0, (%rax), %xmm4, %xmm4
; X64-NEXT:    vinserti128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB6_6: # %else5
; X64-NEXT:    vpextrb $12, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB6_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextracti128 $1, %ymm2, %xmm3
; X64-NEXT:    vpinsrq $1, (%rax), %xmm3, %xmm3
; X64-NEXT:    vinserti128 $1, %xmm3, %ymm2, %ymm2
; X64-NEXT:  .LBB6_8: # %else8
; X64-NEXT:    vpslld $31, %xmm0, %xmm0
; X64-NEXT:    vpmovsxdq %xmm0, %ymm0
; X64-NEXT:    vblendvpd %ymm0, %ymm2, %ymm1, %ymm0
; X64-NEXT:    retq
entry:
  %ld  = load <4 x i64*>, <4 x i64*>* %ptr
  %res = call <4 x i64> @llvm.masked.gather.v4i64(<4 x i64*> %ld, i32 0, <4 x i1> %masks, <4 x i64> %passthro)
  ret <4 x i64> %res
}

declare <4 x double> @llvm.masked.gather.v4double(<4 x double*> %ptrs, i32 %align, <4 x i1> %masks, <4 x double> %passthro)

define <4 x double> @masked_gather_v4double(<4 x double*>* %ptr, <4 x i1> %masks, <4 x double> %passthro) {
; X86-LABEL: masked_gather_v4double:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vmovdqa (%eax), %xmm3
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %YMM2
; X86-NEXT:    je .LBB7_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovsd {{.*#+}} xmm2 = mem[0],zero
; X86-NEXT:  .LBB7_2: # %else
; X86-NEXT:    vpextrb $4, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB7_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $1, %xmm3, %eax
; X86-NEXT:    vmovhpd {{.*#+}} xmm4 = xmm2[0],mem[0]
; X86-NEXT:    vblendpd {{.*#+}} ymm2 = ymm4[0,1],ymm2[2,3]
; X86-NEXT:  .LBB7_4: # %else2
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB7_6
; X86-NEXT:  # BB#5: # %cond.load4
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X86-NEXT:    vmovlpd {{.*#+}} xmm4 = mem[0],xmm4[1]
; X86-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X86-NEXT:  .LBB7_6: # %else5
; X86-NEXT:    vpextrb $12, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB7_8
; X86-NEXT:  # BB#7: # %cond.load7
; X86-NEXT:    vpextrd $3, %xmm3, %eax
; X86-NEXT:    vextractf128 $1, %ymm2, %xmm3
; X86-NEXT:    vmovhpd {{.*#+}} xmm3 = xmm3[0],mem[0]
; X86-NEXT:    vinsertf128 $1, %xmm3, %ymm2, %ymm2
; X86-NEXT:  .LBB7_8: # %else8
; X86-NEXT:    vpslld $31, %xmm0, %xmm0
; X86-NEXT:    vpmovsxdq %xmm0, %ymm0
; X86-NEXT:    vblendvpd %ymm0, %ymm2, %ymm1, %ymm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v4double:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %ymm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %YMM2
; X64-NEXT:    je .LBB7_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovsd {{.*#+}} xmm2 = mem[0],zero
; X64-NEXT:  .LBB7_2: # %else
; X64-NEXT:    vpextrb $4, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB7_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vmovhpd {{.*#+}} xmm4 = xmm2[0],mem[0]
; X64-NEXT:    vblendpd {{.*#+}} ymm2 = ymm4[0,1],ymm2[2,3]
; X64-NEXT:  .LBB7_4: # %else2
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB7_6
; X64-NEXT:  # BB#5: # %cond.load4
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm4
; X64-NEXT:    vmovq %xmm4, %rax
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm4
; X64-NEXT:    vmovlpd {{.*#+}} xmm4 = mem[0],xmm4[1]
; X64-NEXT:    vinsertf128 $1, %xmm4, %ymm2, %ymm2
; X64-NEXT:  .LBB7_6: # %else5
; X64-NEXT:    vpextrb $12, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB7_8
; X64-NEXT:  # BB#7: # %cond.load7
; X64-NEXT:    vextracti128 $1, %ymm3, %xmm3
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vextractf128 $1, %ymm2, %xmm3
; X64-NEXT:    vmovhpd {{.*#+}} xmm3 = xmm3[0],mem[0]
; X64-NEXT:    vinsertf128 $1, %xmm3, %ymm2, %ymm2
; X64-NEXT:  .LBB7_8: # %else8
; X64-NEXT:    vpslld $31, %xmm0, %xmm0
; X64-NEXT:    vpmovsxdq %xmm0, %ymm0
; X64-NEXT:    vblendvpd %ymm0, %ymm2, %ymm1, %ymm0
; X64-NEXT:    retq
entry:
  %ld  = load <4 x double*>, <4 x double*>* %ptr
  %res = call <4 x double> @llvm.masked.gather.v4double(<4 x double*> %ld, i32 0, <4 x i1> %masks, <4 x double> %passthro)
  ret <4 x double> %res
}

declare <2 x i64> @llvm.masked.gather.v2i64(<2 x i64*> %ptrs, i32 %align, <2 x i1> %masks, <2 x i64> %passthro)

define <2 x i64> @masked_gather_v2i64(<2 x i64*>* %ptr, <2 x i1> %masks, <2 x i64> %passthro) {
; X86-LABEL: masked_gather_v2i64:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vpmovzxdq {{.*#+}} xmm3 = mem[0],zero,mem[1],zero
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM2
; X86-NEXT:    je .LBB8_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovq {{.*#+}} xmm2 = mem[0],zero
; X86-NEXT:  .LBB8_2: # %else
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB8_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vpinsrd $2, (%eax), %xmm2, %xmm2
; X86-NEXT:    vpinsrd $3, 4(%eax), %xmm2, %xmm2
; X86-NEXT:  .LBB8_4: # %else2
; X86-NEXT:    vpsllq $63, %xmm0, %xmm0
; X86-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v2i64:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %xmm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM2
; X64-NEXT:    je .LBB8_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovq {{.*#+}} xmm2 = mem[0],zero
; X64-NEXT:  .LBB8_2: # %else
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB8_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vpinsrq $1, (%rax), %xmm2, %xmm2
; X64-NEXT:  .LBB8_4: # %else2
; X64-NEXT:    vpsllq $63, %xmm0, %xmm0
; X64-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X64-NEXT:    retq
entry:
  %ld  = load <2 x i64*>, <2 x i64*>* %ptr
  %res = call <2 x i64> @llvm.masked.gather.v2i64(<2 x i64*> %ld, i32 0, <2 x i1> %masks, <2 x i64> %passthro)
  ret <2 x i64> %res
}

declare <2 x double> @llvm.masked.gather.v2double(<2 x double*> %ptrs, i32 %align, <2 x i1> %masks, <2 x double> %passthro)

define <2 x double> @masked_gather_v2double(<2 x double*>* %ptr, <2 x i1> %masks, <2 x double> %passthro) {
; X86-LABEL: masked_gather_v2double:
; X86:       # BB#0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    vpmovzxdq {{.*#+}} xmm3 = mem[0],zero,mem[1],zero
; X86-NEXT:    vpextrb $0, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    # implicit-def: %XMM2
; X86-NEXT:    je .LBB9_2
; X86-NEXT:  # BB#1: # %cond.load
; X86-NEXT:    vmovd %xmm3, %eax
; X86-NEXT:    vmovsd {{.*#+}} xmm2 = mem[0],zero
; X86-NEXT:  .LBB9_2: # %else
; X86-NEXT:    vpextrb $8, %xmm0, %eax
; X86-NEXT:    testb $1, %al
; X86-NEXT:    je .LBB9_4
; X86-NEXT:  # BB#3: # %cond.load1
; X86-NEXT:    vpextrd $2, %xmm3, %eax
; X86-NEXT:    vmovhpd {{.*#+}} xmm2 = xmm2[0],mem[0]
; X86-NEXT:  .LBB9_4: # %else2
; X86-NEXT:    vpsllq $63, %xmm0, %xmm0
; X86-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X86-NEXT:    retl
;
; X64-LABEL: masked_gather_v2double:
; X64:       # BB#0: # %entry
; X64-NEXT:    vmovdqa (%rdi), %xmm3
; X64-NEXT:    vpextrb $0, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    # implicit-def: %XMM2
; X64-NEXT:    je .LBB9_2
; X64-NEXT:  # BB#1: # %cond.load
; X64-NEXT:    vmovq %xmm3, %rax
; X64-NEXT:    vmovsd {{.*#+}} xmm2 = mem[0],zero
; X64-NEXT:  .LBB9_2: # %else
; X64-NEXT:    vpextrb $8, %xmm0, %eax
; X64-NEXT:    testb $1, %al
; X64-NEXT:    je .LBB9_4
; X64-NEXT:  # BB#3: # %cond.load1
; X64-NEXT:    vpextrq $1, %xmm3, %rax
; X64-NEXT:    vmovhpd {{.*#+}} xmm2 = xmm2[0],mem[0]
; X64-NEXT:  .LBB9_4: # %else2
; X64-NEXT:    vpsllq $63, %xmm0, %xmm0
; X64-NEXT:    vblendvpd %xmm0, %xmm2, %xmm1, %xmm0
; X64-NEXT:    retq
entry:
  %ld  = load <2 x double*>, <2 x double*>* %ptr
  %res = call <2 x double> @llvm.masked.gather.v2double(<2 x double*> %ld, i32 0, <2 x i1> %masks, <2 x double> %passthro)
  ret <2 x double> %res
}

